use std::str::FromStr;
use crate::ast::*;

grammar;

pub Type: Type = {
    "i32" => Type::Int32,
    "bool" => Type::Bool,
    "()" => Type::Unit
}

pub Program: Program = {
    <stmts: (<Stmt>)*> => Program {<>}
}

pub Stmt: Stmt = {
    "let" <id: Identifier> "=" <e: Expr> ";" => Stmt::Let(Some(id), e, false),
    "let" "mut" <id: Identifier> "=" <e: Expr> ";" => Stmt::Let(Some(id), e, true),
    <e: Expr> ";" => Stmt::Let(None, e, false)
}

pub Expr: TypedExpr = {
    ExprAssign
}

pub ExprAssign: TypedExpr = {
    <lhs: ExprAssign> "=" <rhs: ExprOr> => Expr::Assign(<>).into(),
    ExprOr
}

pub ExprOr: TypedExpr = {
    <e1: ExprAnd> "||" <e2: ExprOr> => Expr::Or(<>).into(),
    ExprAnd
}

pub ExprAnd: TypedExpr = {
    <e1: ExprCmp> "&&" <e2: ExprAnd> => Expr::And(<>).into(),
    ExprCmp
}


pub ExprCmp: TypedExpr = {
    <e1: ExprBop1> <cmp: Cmp> <e2: ExprCmp> => Expr::Cmp {<>}.into(),
    ExprBop1
}

pub ExprBop1: TypedExpr = {
    <e1: ExprBop2> <bop: Bop1> <e2: ExprBop1> => Expr::Bop {<>}.into(),
    ExprBop2
};

pub ExprBop2: TypedExpr = {
    <e1: Term> <bop: Bop2> <e2: ExprBop2> => Expr::Bop {<>}.into(),
    Term
}

pub Term: TypedExpr = {
    Literal => Expr::Literal(<>).into(),
    "if" <condition: Expr> <then:Block> "else" <otherwise:Block>
        => Expr::If {<>}.into(),
    "while" <condition:Expr> <body:Block> => Expr::While {<>}.into(),
    "print" "(" <Expr> ")" => Expr::Print(<>).into(), 
    "!" <Term> => Expr::Not(<>).into(),
    "(" <Expr> ")",
    Identifier => Expr::Var(<>).into(),
    Block,
    
}

pub Block: TypedExpr = {
    "{" <Stmt*> "}" => Expr::Block(<>, Expr::Literal(Literal::Unit).into()).into(),
    "{" <Stmt*> <Expr> "}" => Expr::Block(<>).into()
}

Bop1: Bop = { 
    "+" => Bop::Add,
    "-" => Bop::Sub,
};

Bop2: Bop = { 
    "*" => Bop::Mul,
    "/" => Bop::Div,
};

Cmp: Cmp = {
    "==" => Cmp::Eq,
    "!=" => Cmp::Neq,
    "<" => Cmp::Lt,
    "<=" => Cmp::Le,
    ">" => Cmp::Gt,
    ">=" => Cmp::Ge,
};

Literal: Literal = {
    r"[0-9]+" => Literal::Num(i32::from_str(<>).unwrap()),
    "(" ")" => Literal::Unit,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false)
};

Identifier: Identifier = {
    r"[a-zA-Z_]+[a-zA-Z0-9_]*" => Identifier::Identifier(<>.to_string())
}
