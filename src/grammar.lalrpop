use std::str::FromStr;
use crate::ast::*;

grammar;

pub Type: Type = {
    "i32" => Type::Int32,
    "bool" => Type::Bool,
    "()" => Type::Unit
}

pub Program: Program = {
    <stmts: (<Stmt>)*> => Program {<>}
}

pub Stmt: Stmt = {
    "let" <id: Identifier> "=" <e: Expr> ";" => Stmt::Let(Some(id), e, false),
    "let" "mut" <id: Identifier> "=" <e: Expr> ";" => Stmt::Let(Some(id), e, true),
    <e: Expr> ";" => Stmt::Let(None, e, false)
}

pub Expr: TypedExpr = {
    <e1: Expr> <bop: Bop1> <e2: Factor> => Expr::Bop {<>}.into(),
    Factor,
};

pub Factor: TypedExpr = {
    <e1: Factor> <bop: Bop2> <e2: Term> => Expr::Bop {<>}.into(),
    Term
}

pub Term: TypedExpr = {
    Literal => Expr::Literal(<>).into(),
    "if" <condition: Expr> <then:Block> "else" <otherwise:Block>
         => Expr::If {<>}.into(),
    "print" "(" <Expr> ")" => Expr::Print(<>).into(), 
    "(" <Expr> ")",
    Identifier => Expr::Var(<>).into(),
    Block
}

pub Block: TypedExpr = {
    "{" <Stmt*> "}" => Expr::Block(<>, Expr::Literal(Literal::Unit).into()).into(),
    "{" <Stmt*> <Expr> "}" => Expr::Block(<>).into()
}

Bop1: Bop = { 
    "+" => Bop::Add,
    "-" => Bop::Sub,
};

Bop2: Bop = { 
    "*" => Bop::Mul,
    "/" => Bop::Div,
};

Literal: Literal = {
    r"[0-9]+" => Literal::Num(i32::from_str(<>).unwrap()),
    "(" ")" => Literal::Unit,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false)
};

Identifier: Identifier = {
    r"[a-zA-Z_]+[a-zA-Z0-9_]*" => Identifier::Identifier(<>.to_string())
}
